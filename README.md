**Загрузить кодъ, надобы**

Задача:
Создать приложение для android для стриминга пользовательских матчей на YouTube.

Используемые API: 
Нам понадобится java SE, Android Studio, документация YouTube, документация по FFmpeg.

Реализация:
Прежде всего нужно продумать схему всех модулей и их взаимодействия, а уже после рассматривать детальную их реализацию. 
Итак возьмем за основу MVC модель и немного изменим ее. В нашем случае Model - FFmpeg, Viev - интерфейс приложения(кнопочки и понельки), Controller - непосредственно сервера YouTube, но для этого нам нужно дописать несколько запросов к нему.
Что же получилось? 
Пользователь открывает приложение устанавливает параметры для трансляции(теги, название и тд.), после происходит ряд запросов к серверу YouTube для создания самой трансляции(конечно в фоновом режиме, часть из которых будет совершаться на этапе входа в приложение, чтобы пользователю не нужно было ждать). На протяжении всей трансляции пользователь управляет всем процессом стриминга(ведет счет матча и тп.) по средствам интерфейса(Viev).

А теперь более подробно обо всем.
Кака вы наверно заметили, все приложение делится на 3 основных блока: интерфейс приложения, стек запросов к сереверу, управление процессом трансляции. Если с первыми 2 пунктами все ясно, то вот с 3им все сложнее. Стои объяснить, что для этого пункта будем использовать, чтобы стало все ясно. 
FFmpeg - это набор свободных библиотек с открытым исходным кодом, которые позволяют записывать, конвертировать и передавать цифровые аудио- и видеозаписи в различных форматах(определение из Википедии).
Итак, с основными модулями и их связыванием разобрались, теперь расскажу о их детальной реализации. 
Но для начало подведу итоги.

- интерфейсы приложения
    Должен состоять из 2 страничек и быть максимально понятным и легким. На первой странице будет будет выбор настроек самой трансляции, внизу этой стр. будет большая кнопка "начать трансляцию". После будет происходить переход на 2 стр. На которой будет осуществляться доступ к камере и вывод на экран изображения(по сути обычная камера), при этом должна накладываться понель взаимодействия пользователя с приложением(частота кадров, окончание трансляции и тд.), а также понель игрового счета(всетаки приложение для стриминга пользовательских матчей).  
    1) реализовать все стр 
    2) 
    3) 
    ...

- стек запросов к сереверу
    Прежде всего нужно начать с теории. 
    Для начала необходимо ознакомиться с данной докой. https://developers.google.com/youtube/v3/live/getting-started
    YouTube Live Streaming API позволяет управлять событиями на YouTube(трансляция в том числе). Broadcasts и streams, вот на что нужно обратить внимание(cuepoints пока не особо нужны, если вы не хотите вставлять в трансляцию какие-то видеоряды). 
    Итак Broadcast - это сама трансляция, которую можно смотреть(если в кратце, то это окно по которому мы все кликаем, когда хотим посмотреть какойто контент на YouTube). 
    Stream - это поток самого контента(идентификатор видео), тоесть непосредственно множество байт, передаваймых по сети. 
    Важное замечание! Каждая трансляция должна быть связана с одним потоком. Отсюда вытекает вопрос, а как же создаются видео с разным разрешением? Забигая вперед скажу, что для этого используется специальный формат видео HLS (HTTP Live Streaming), но об этом позже.
    Важно! Все запросы к серверу должны осущетвляться со специальным ключем, полученным после авторизации через google аккаунт. Также результаты запросов будут отпрвляться в формате json.
   В контексте данной задачи мне понадобились следующие ресурсы: liveBroadcast и liveStream. Внезапно, не правда ли? 
   Опирации которые можно использовать для ресурсов следующие: list, insert, update, bind, transition, control, delete. Если вы работали с базами данных, то эти опирации знакомы вам, но все же я расскажу о каждой по подробнее в момент их непосредственного использования.
   К liveBroadcast можно использовать све опирации, а к liveStream все кроме bind, transition, control. 
  
   Теперь перейду к самим запросам. Забегая вперед скажу, что все запросы будем тестировать тут: https://developers.google.com/apis-explorer/#s/youtube/v3/ , после можно будет перейти в intellij idea и написать методы уже там.
   Важно!!! Это замечание относится ко всем запросам. В формате ресурса вы можете увидеть структуру самого ресурса. По каждому запросу сервер вам будет возвращать те части ресурса, которые вы указали в запросе. Объясню, сам ресурс делится на несколько частей, например liveBroadcast делится на:  id, snippet, contentDetails, and status, где каждая часть несет в себе некую сгруппированную информацию. В самом запросе вы ДОЛЖНЫ указать в параметре part те части, каторые вы хотите получить в ответ от сервера. Обратите внимание на то, что не стоит указывать все части это может привести к паттовым ситуациям в дальнейшем(агрументы в пользу этого приведены здесь: https://developers.google.com/youtube/v3/live/getting-started в разделе Partial resources). Узнать о том какие бывают части вы можете из самой структуры ресурса или же просто посмотрев на описание part для каждого запроса из https://developers.google.com/apis-explorer/#s/youtube/v3/.
   Рассмотрим ресурс liveBroadcast. (https://developers.google.com/youtube/v3/live/docs/liveBroadcasts) 
   Чтобы создать трансляцию нам нужен метод insert. (https://developers.google.com/apis-explorer/#s/youtube/v3/youtube.liveBroadcasts.insert)
   Я опишу подробно только этот метод, т.к. все остальные методы схожи по построению.
   В Request body указываются все параметры запроса, которые формируют саму трансляцию(название трансляции и тд.)
   Важно! Request body должны содержать некоторые обязательный параметры, для данного метода и ресурса - это snippet.title, snippet.scheduledStartTime, status.privacyStatus. О том, что охзначает каждый параметр можно узнать свойств ресурса.
   Итак snippet.title - название трансляции (пусть будет - "Hello world!", традиции нарушать нельзя)
   snippet.scheduledStartTime - дата и время начала трансляции, в формате ISO 8601 (YYYY-MM-DDThh:mm:ss.sZ)  (например, 2999-02-01T22:22:00+03, теперь нужно долго ждать) 
   status.privacyStatus - статус конфиденциальности трансляции (я устанавлю его public)
   После нажмите на кнопку "Authorize and execute" и далее происходит авторизация вашего запроса через google аккаунт и уже после вы сотрите на результат. Если результат пришел с кодом 200 все хорошо и вы можете перейти на свой тестовый канал и любуйтесь тем, что вышло. 	
   Важно! Запомните полученный id из ответа, он нам еще понадобится и не раз. Также обратите внимание на эту строчку: POST https://www.googleapis.com/youtube/v3/liveBroadcasts?part=id%2Csnippet%2CcontentDetails%2Cstatus&key={YOUR_API_KEY} 
   Здесь YOUR_API_KEY - тот самый ключ, о котором я говорил, его получаем при авторизации на google аккаунте, но т.к. мы ручками тут делаем всю авторизацию, то "под капотом" на данной стр. происходит просто подстановка нашего ключа.
   Изучите детально данный документ: https://developers.google.com/youtube/v3/live/docs/liveBroadcasts
   
   Итак двинемся дальше, рассмотривать оставшиеся методы будем в перемешку с методами для ресурса liveStreams.
   
   - Аналогично методы insert для liveBroadcasts можно создать liveStreams, но уже будут использоваться немного другие параметры. Приведу пример только обязательных: snippet.title, cdn.format, cdn.ingestionType.
   .snippet.title - имя потока. 
   .cdn.format - формат видео, позволяющий задать  частоту кадров и разрешение(например 1080p). Увы, но это свойство устаревшее начиная с 18 апреля 2016 г. Вместо этого используется cdn.frameRateи cdn.resolutionсвойство, чтобы определить частоту кадров и разрешение отдельно. Однако правила нужны чтобы их нарушать, поэтому буду в примере(ТОЛЬКО в примере) использовать format.
   .cdn.ingestionType - что-то вроде протокола, используемого для передачи видеопотока. Почему "что-то вроде"? Отвечаю. cdn.ingestionType может принимать 1 из двух возможных значений dash и rtmp(его я и буду использовать). RTMP - проприетарный протокол потоковой передачи данных, в основном используется для передачи потокового видео и аудиопотоков с веб-камер через интернет. DASH - технология адаптивной потоковой передачи данных, предоставляющая возможность доставки потокового мультимедиа-контента через Интернет по протоколу HTTP. 
   Отправляем запрос, получаем ответ, сохраняем id.
   
   Теперь перейдем к методу bind ресурса liveBroadcasts. Этот метод отвечает за связвание Broadcast с Streams.
   Как вы наверно догадались тут и понадобятся те самые id. 
   Забавное замечание! "A broadcast can only be bound to one video stream, though a video stream may be bound to more than one broadcast". Однако это немного противоречит их же документации, если помните я упомянал это ранее, что на один broadcast приходится один Streams. Конечно же я все проверил и ........
   А вот и сам запрос. Хоть это и POST запрос, однако у него нет body как такового. Но есть параметры, должны указываться в самом запросе: part(об этом вы уже знаете, id, snippet, contentDetails, and status), id(id broadcast) и streamId(id stream).
   Отправили запрос, получили ответ, проверили что код 200 и можно идти дальше.
   
   
   
   
   
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

# LiveStream
https://developers.google.com/apis-explorer/#p/youtube/v3/youtube.liveBroadcasts.insert?part=id%252Csnippet%252CcontentDetails%252Cstatus&_h=1&resource=%257B%250A++%2522snippet%2522%253A+%250A++%257B%250A++++%2522scheduledStartTime%2522%253A+%25222018-10-03T20%253A20%253A00%252B03%253A00%2522%252C%250A++++%2522title%2522%253A+%2522hello2%2522%250A++%257D%252C%250A++%2522status%2522%253A+%250A++%257B%250A++++%2522privacyStatus%2522%253A+%2522public%2522%250A++%257D%250A%257D&

https://developers.google.com/apis-explorer/#p/youtube/v3/youtube.liveStreams.insert?part=id%252Csnippet%252Ccdn%252Cstatus&_h=1&resource=%257B%250A++%2522snippet%2522%253A+%250A++%257B%250A++++%2522title%2522%253A+%2522hi%2522%250A++%257D%252C%250A++%2522cdn%2522%253A+%250A++%257B%250A++++%2522format%2522%253A+%25221080p%2522%252C%250A++++%2522ingestionType%2522%253A+%2522rtmp%2522%250A++%257D%250A%257D&

https://developers.google.com/apis-explorer/#p/youtube/v3/youtube.liveBroadcasts.bind?id=Mnjv0fGbx6E&part=id%252Csnippet%252CcontentDetails%252Cstatus&streamId=ENp2jseLjEdhoteLLuknHw1538587984167798&_h=1&

https://developers.google.com/apis-explorer/#p/youtube/v3/youtube.liveBroadcasts.list

https://developers.google.com/apis-explorer/#p/youtube/v3/youtube.liveStreams.list?part=id%252Csnippet%252Ccdn%252Cstatus&id=ENp2jseLjEdhoteLLuknHw1538587051302969&_h=1&

https://developers.google.com/apis-explorer/#p/youtube/v3/youtube.liveBroadcasts.transition?broadcastStatus=complete&id=Mnjv0fGbx6E&part=id%252Csnippet%252CcontentDetails%252Cstatus&_h=4&

https://developers.google.com/youtube/v3/live/docs/liveBroadcasts/transition#params

VBR="2500k"                                    # Bitrate de la vidéo en sortie
FPS="30"                                       # FPS de la vidéo en sortie
QUAL="medium"                                  # Preset de qualité FFMPEG
YOUTUBE_URL="rtmp://a.rtmp.youtube.com/live2"  # URL de base RTMP youtube

SOURCE="udp://239.255.139.0:1234"              # Source UDP (voir les annonces SAP)
KEY="...."                                     # Clé à récupérer sur l'event youtube

ffmpeg \
    -i "$SOURCE" -deinterlace \
    -vcodec libx264 -pix_fmt yuv420p -preset $QUAL -r $FPS -g $(($FPS * 2)) -b:v $VBR \
    -acodec libmp3lame -ar 44100 -threads 6 -qscale 3 -b:a 712000 -bufsize 512k \
    -f flv "$YOUTUBE_URL/$KEY"
    
    
    
   ffmpeg -i 355295.mp4 -deinterlace -vcodec libx264 -pix_fmt yuv420p -preset medium -r 30 -g 60 -b:v 2500k -acodec libmp3lame -ar 44100 -threads 6 -qscale 3 -b:a 712000 -bufsize 512k -f flv rtmp://a.rtmp.youtube.com/live2/bkj4-zk8s-5h14-4rag
    
    

Основной поток:
Видеопоток поступает слишком медленно. Просмотр может идти с буферизацией.
Основной поток:
Текущее разрешение (640x360) не поддерживается на YouTube. Рекомендуем использовать формат 1920 x 1080.
Основной поток:
Низкая скорость передачи данных. У зрителей могут возникнуть проблемы с буферизацией. Проверьте скорость соединения или используйте более низкий битрейт.
3 октября 2018 г., 10:38 (GMT-7)
Основной поток:
Видеопоток поступает слишком медленно. Просмотр может идти с буферизацией.
Основной поток:
Текущее разрешение (640x360) не поддерживается на YouTube. Рекомендуем использовать формат 1920 x 1080.
Основной поток:
Низкая скорость передачи данных. У зрителей могут возникнуть проблемы с буферизацией. Проверьте скорость соединения или используйте более низкий битрейт.
